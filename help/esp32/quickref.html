<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Quick reference for the ESP32 &mdash; MicroPython 1.16 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/customstyle.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="General information about the ESP32 port" href="general.html" />
    <link rel="prev" title="15. Next steps" href="../esp8266/tutorial/nextsteps.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> MicroPython
          </a>
              <div class="version">
                1.16
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../library/index.html">MicroPython libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../reference/index.html">MicroPython language and implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../genrst/index.html">MicroPython differences from CPython</a></li>
<li class="toctree-l1"><a class="reference internal" href="../develop/index.html">MicroPython Internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="../license.html">MicroPython license information</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pyboard/quickref.html">Quick reference for the pyboard</a></li>
<li class="toctree-l1"><a class="reference internal" href="../esp8266/quickref.html">Quick reference for the ESP8266</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Quick reference for the ESP32</a><ul>
<li class="toctree-l2"><a class="reference internal" href="general.html">General information about the ESP32 port</a></li>
<li class="toctree-l2"><a class="reference internal" href="tutorial/intro.html">Getting started with MicroPython on the ESP32</a></li>
<li class="toctree-l2"><a class="reference internal" href="#installing-micropython">Installing MicroPython</a></li>
<li class="toctree-l2"><a class="reference internal" href="#general-board-control">General board control</a></li>
<li class="toctree-l2"><a class="reference internal" href="#networking">Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="#delay-and-timing">Delay and timing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#timers">Timers</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pins-and-gpio">Pins and GPIO</a></li>
<li class="toctree-l2"><a class="reference internal" href="#uart-serial-bus">UART (serial bus)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pwm-pulse-width-modulation">PWM (pulse width modulation)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#adc-analog-to-digital-conversion">ADC (analog to digital conversion)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#software-spi-bus">Software SPI bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hardware-spi-bus">Hardware SPI bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="#software-i2c-bus">Software I2C bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hardware-i2c-bus">Hardware I2C bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="#i2s-bus">I2S bus</a></li>
<li class="toctree-l2"><a class="reference internal" href="#real-time-clock-rtc">Real time clock (RTC)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#wdt-watchdog-timer">WDT (Watchdog timer)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#deep-sleep-mode">Deep-sleep mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sd-card">SD card</a></li>
<li class="toctree-l2"><a class="reference internal" href="#rmt">RMT</a></li>
<li class="toctree-l2"><a class="reference internal" href="#onewire-driver">OneWire driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="#neopixel-and-apa106-driver">NeoPixel and APA106 driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="#capacitive-touch">Capacitive touch</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dht-driver">DHT driver</a></li>
<li class="toctree-l2"><a class="reference internal" href="#webrepl-web-browser-interactive-prompt">WebREPL (web browser interactive prompt)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../rp2/quickref.html">Quick reference for the RP2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../wipy/quickref.html">Quick reference for the WiPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../unix/quickref.html">Quick reference for the UNIX and Windows ports</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zephyr/quickref.html">Quick reference for the Zephyr port</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">MicroPython</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Quick reference for the ESP32</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/esp32/quickref.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="quick-reference-for-the-esp32">
<span id="esp32-quickref"></span><h1>Quick reference for the ESP32<a class="headerlink" href="#quick-reference-for-the-esp32" title="Permalink to this headline">¶</a></h1>
<a class="reference internal image-reference" href="../_images/esp32.jpg"><img alt="ESP32 board" src="../_images/esp32.jpg" style="width: 640px;" /></a>
<p>The Espressif ESP32 Development Board (image attribution: Adafruit).</p>
<p>Below is a quick reference for ESP32-based boards.  If it is your first time
working with this board it may be useful to get an overview of the microcontroller:</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="general.html">General information about the ESP32 port</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial/intro.html">Getting started with MicroPython on the ESP32</a></li>
</ul>
</div>
<section id="installing-micropython">
<h2>Installing MicroPython<a class="headerlink" href="#installing-micropython" title="Permalink to this headline">¶</a></h2>
<p>See the corresponding section of tutorial: <a class="reference internal" href="tutorial/intro.html#esp32-intro"><span class="std std-ref">Getting started with MicroPython on the ESP32</span></a>. It also includes
a troubleshooting subsection.</p>
</section>
<section id="general-board-control">
<h2>General board control<a class="headerlink" href="#general-board-control" title="Permalink to this headline">¶</a></h2>
<p>The MicroPython REPL is on UART0 (GPIO1=TX, GPIO3=RX) at baudrate 115200.
Tab-completion is useful to find out what methods an object has.
Paste mode (ctrl-E) is useful to paste a large slab of Python code into
the REPL.</p>
<p>The <a class="reference internal" href="../library/machine.html#module-machine" title="machine: functions related to the hardware"><code class="xref py py-mod docutils literal notranslate"><span class="pre">machine</span></code></a> module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">machine</span>

<span class="n">machine</span><span class="o">.</span><span class="n">freq</span><span class="p">()</span>          <span class="c1"># get the current frequency of the CPU</span>
<span class="n">machine</span><span class="o">.</span><span class="n">freq</span><span class="p">(</span><span class="mi">240000000</span><span class="p">)</span> <span class="c1"># set the CPU frequency to 240 MHz</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../library/esp.html#module-esp" title="esp: functions related to the ESP8266 and ESP32"><code class="xref py py-mod docutils literal notranslate"><span class="pre">esp</span></code></a> module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">esp</span>

<span class="n">esp</span><span class="o">.</span><span class="n">osdebug</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>       <span class="c1"># turn off vendor O/S debugging messages</span>
<span class="n">esp</span><span class="o">.</span><span class="n">osdebug</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>          <span class="c1"># redirect vendor O/S debugging messages to UART(0)</span>

<span class="c1"># low level methods to interact with flash storage</span>
<span class="n">esp</span><span class="o">.</span><span class="n">flash_size</span><span class="p">()</span>
<span class="n">esp</span><span class="o">.</span><span class="n">flash_user_start</span><span class="p">()</span>
<span class="n">esp</span><span class="o">.</span><span class="n">flash_erase</span><span class="p">(</span><span class="n">sector_no</span><span class="p">)</span>
<span class="n">esp</span><span class="o">.</span><span class="n">flash_write</span><span class="p">(</span><span class="n">byte_offset</span><span class="p">,</span> <span class="n">buffer</span><span class="p">)</span>
<span class="n">esp</span><span class="o">.</span><span class="n">flash_read</span><span class="p">(</span><span class="n">byte_offset</span><span class="p">,</span> <span class="n">buffer</span><span class="p">)</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="../library/esp32.html#module-esp32" title="esp32: functionality specific to the ESP32"><code class="xref py py-mod docutils literal notranslate"><span class="pre">esp32</span></code></a> module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">esp32</span>

<span class="n">esp32</span><span class="o">.</span><span class="n">hall_sensor</span><span class="p">()</span>     <span class="c1"># read the internal hall sensor</span>
<span class="n">esp32</span><span class="o">.</span><span class="n">raw_temperature</span><span class="p">()</span> <span class="c1"># read the internal temperature of the MCU, in Fahrenheit</span>
<span class="n">esp32</span><span class="o">.</span><span class="n">ULP</span><span class="p">()</span>             <span class="c1"># access to the Ultra-Low-Power Co-processor</span>
</pre></div>
</div>
<p>Note that the temperature sensor in the ESP32 will typically read higher than
ambient due to the IC getting warm while it runs.  This effect can be minimised
by reading the temperature sensor immediately after waking up from sleep.</p>
</section>
<section id="networking">
<h2>Networking<a class="headerlink" href="#networking" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="../library/network.html#module-network" title="network: network configuration"><code class="xref py py-mod docutils literal notranslate"><span class="pre">network</span></code></a> module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">network</span>

<span class="n">wlan</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">WLAN</span><span class="p">(</span><span class="n">network</span><span class="o">.</span><span class="n">STA_IF</span><span class="p">)</span> <span class="c1"># create station interface</span>
<span class="n">wlan</span><span class="o">.</span><span class="n">active</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>       <span class="c1"># activate the interface</span>
<span class="n">wlan</span><span class="o">.</span><span class="n">scan</span><span class="p">()</span>             <span class="c1"># scan for access points</span>
<span class="n">wlan</span><span class="o">.</span><span class="n">isconnected</span><span class="p">()</span>      <span class="c1"># check if the station is connected to an AP</span>
<span class="n">wlan</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;essid&#39;</span><span class="p">,</span> <span class="s1">&#39;password&#39;</span><span class="p">)</span> <span class="c1"># connect to an AP</span>
<span class="n">wlan</span><span class="o">.</span><span class="n">config</span><span class="p">(</span><span class="s1">&#39;mac&#39;</span><span class="p">)</span>      <span class="c1"># get the interface&#39;s MAC address</span>
<span class="n">wlan</span><span class="o">.</span><span class="n">ifconfig</span><span class="p">()</span>         <span class="c1"># get the interface&#39;s IP/netmask/gw/DNS addresses</span>

<span class="n">ap</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">WLAN</span><span class="p">(</span><span class="n">network</span><span class="o">.</span><span class="n">AP_IF</span><span class="p">)</span> <span class="c1"># create access-point interface</span>
<span class="n">ap</span><span class="o">.</span><span class="n">config</span><span class="p">(</span><span class="n">essid</span><span class="o">=</span><span class="s1">&#39;ESP-AP&#39;</span><span class="p">)</span> <span class="c1"># set the ESSID of the access point</span>
<span class="n">ap</span><span class="o">.</span><span class="n">config</span><span class="p">(</span><span class="n">max_clients</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># set how many clients can connect to the network</span>
<span class="n">ap</span><span class="o">.</span><span class="n">active</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>         <span class="c1"># activate the interface</span>
</pre></div>
</div>
<p>A useful function for connecting to your local WiFi network is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">do_connect</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">network</span>
    <span class="n">wlan</span> <span class="o">=</span> <span class="n">network</span><span class="o">.</span><span class="n">WLAN</span><span class="p">(</span><span class="n">network</span><span class="o">.</span><span class="n">STA_IF</span><span class="p">)</span>
    <span class="n">wlan</span><span class="o">.</span><span class="n">active</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">wlan</span><span class="o">.</span><span class="n">isconnected</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;connecting to network...&#39;</span><span class="p">)</span>
        <span class="n">wlan</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;essid&#39;</span><span class="p">,</span> <span class="s1">&#39;password&#39;</span><span class="p">)</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">wlan</span><span class="o">.</span><span class="n">isconnected</span><span class="p">():</span>
            <span class="k">pass</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;network config:&#39;</span><span class="p">,</span> <span class="n">wlan</span><span class="o">.</span><span class="n">ifconfig</span><span class="p">())</span>
</pre></div>
</div>
<p>Once the network is established the <a class="reference internal" href="../library/socket.html#module-socket" title="socket: socket module"><code class="xref py py-mod docutils literal notranslate"><span class="pre">socket</span></code></a> module can be used
to create and use TCP/UDP sockets as usual, and the <code class="docutils literal notranslate"><span class="pre">urequests</span></code> module for
convenient HTTP requests.</p>
<p>After a call to <code class="docutils literal notranslate"><span class="pre">wlan.connect()</span></code>, the device will by default retry to connect
<strong>forever</strong>, even when the authentication failed or no AP is in range.
<code class="docutils literal notranslate"><span class="pre">wlan.status()</span></code> will return <code class="docutils literal notranslate"><span class="pre">network.STAT_CONNECTING</span></code> in this state until a
connection succeeds or the interface gets disabled.  This can be changed by
calling <code class="docutils literal notranslate"><span class="pre">wlan.config(reconnects=n)</span></code>, where n are the number of desired reconnect
attempts (0 means it won’t retry, -1 will restore the default behaviour of trying
to reconnect forever).</p>
</section>
<section id="delay-and-timing">
<h2>Delay and timing<a class="headerlink" href="#delay-and-timing" title="Permalink to this headline">¶</a></h2>
<p>Use the <a class="reference internal" href="../library/time.html#module-time" title="time: time related functions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">time</span></code></a> module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span>

<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>           <span class="c1"># sleep for 1 second</span>
<span class="n">time</span><span class="o">.</span><span class="n">sleep_ms</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>      <span class="c1"># sleep for 500 milliseconds</span>
<span class="n">time</span><span class="o">.</span><span class="n">sleep_us</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>       <span class="c1"># sleep for 10 microseconds</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">ticks_ms</span><span class="p">()</span> <span class="c1"># get millisecond counter</span>
<span class="n">delta</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">ticks_diff</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">ticks_ms</span><span class="p">(),</span> <span class="n">start</span><span class="p">)</span> <span class="c1"># compute time difference</span>
</pre></div>
</div>
</section>
<section id="timers">
<h2>Timers<a class="headerlink" href="#timers" title="Permalink to this headline">¶</a></h2>
<p>The ESP32 port has four hardware timers. Use the <a class="reference internal" href="../library/machine.Timer.html#machine-timer"><span class="std std-ref">machine.Timer</span></a> class
with a timer ID from 0 to 3 (inclusive):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">Timer</span>

<span class="n">tim0</span> <span class="o">=</span> <span class="n">Timer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">tim0</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">period</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">Timer</span><span class="o">.</span><span class="n">ONE_SHOT</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span><span class="nb">print</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

<span class="n">tim1</span> <span class="o">=</span> <span class="n">Timer</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">tim1</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">period</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">Timer</span><span class="o">.</span><span class="n">PERIODIC</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span><span class="nb">print</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>The period is in milliseconds.</p>
<p>Virtual timers are not currently supported on this port.</p>
</section>
<section id="pins-and-gpio">
<span id="id1"></span><h2>Pins and GPIO<a class="headerlink" href="#pins-and-gpio" title="Permalink to this headline">¶</a></h2>
<p>Use the <a class="reference internal" href="../library/machine.Pin.html#machine-pin"><span class="std std-ref">machine.Pin</span></a> class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">Pin</span>

<span class="n">p0</span> <span class="o">=</span> <span class="n">Pin</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Pin</span><span class="o">.</span><span class="n">OUT</span><span class="p">)</span>    <span class="c1"># create output pin on GPIO0</span>
<span class="n">p0</span><span class="o">.</span><span class="n">on</span><span class="p">()</span>                 <span class="c1"># set pin to &quot;on&quot; (high) level</span>
<span class="n">p0</span><span class="o">.</span><span class="n">off</span><span class="p">()</span>                <span class="c1"># set pin to &quot;off&quot; (low) level</span>
<span class="n">p0</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>             <span class="c1"># set pin to on/high</span>

<span class="n">p2</span> <span class="o">=</span> <span class="n">Pin</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">Pin</span><span class="o">.</span><span class="n">IN</span><span class="p">)</span>     <span class="c1"># create input pin on GPIO2</span>
<span class="nb">print</span><span class="p">(</span><span class="n">p2</span><span class="o">.</span><span class="n">value</span><span class="p">())</span>       <span class="c1"># get value, 0 or 1</span>

<span class="n">p4</span> <span class="o">=</span> <span class="n">Pin</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">Pin</span><span class="o">.</span><span class="n">IN</span><span class="p">,</span> <span class="n">Pin</span><span class="o">.</span><span class="n">PULL_UP</span><span class="p">)</span> <span class="c1"># enable internal pull-up resistor</span>
<span class="n">p5</span> <span class="o">=</span> <span class="n">Pin</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">Pin</span><span class="o">.</span><span class="n">OUT</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># set pin high on creation</span>
</pre></div>
</div>
<p>Available Pins are from the following ranges (inclusive): 0-19, 21-23, 25-27, 32-39.
These correspond to the actual GPIO pin numbers of ESP32 chip.  Note that many
end-user boards use their own adhoc pin numbering (marked e.g. D0, D1, …).
For mapping between board logical pins and physical chip pins consult your board
documentation.</p>
<p>Notes:</p>
<ul class="simple">
<li><p>Pins 1 and 3 are REPL UART TX and RX respectively</p></li>
<li><p>Pins 6, 7, 8, 11, 16, and 17 are used for connecting the embedded flash,
and are not recommended for other uses</p></li>
<li><p>Pins 34-39 are input only, and also do not have internal pull-up resistors</p></li>
<li><p>The pull value of some pins can be set to <code class="docutils literal notranslate"><span class="pre">Pin.PULL_HOLD</span></code> to reduce power
consumption during deepsleep.</p></li>
</ul>
<p>There’s a higher-level abstraction <a class="reference internal" href="../library/machine.Signal.html#machine-signal"><span class="std std-ref">machine.Signal</span></a>
which can be used to invert a pin. Useful for illuminating active-low LEDs
using <code class="docutils literal notranslate"><span class="pre">on()</span></code> or <code class="docutils literal notranslate"><span class="pre">value(1)</span></code>.</p>
</section>
<section id="uart-serial-bus">
<h2>UART (serial bus)<a class="headerlink" href="#uart-serial-bus" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="../library/machine.UART.html#machine-uart"><span class="std std-ref">machine.UART</span></a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">UART</span>

<span class="n">uart1</span> <span class="o">=</span> <span class="n">UART</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">baudrate</span><span class="o">=</span><span class="mi">9600</span><span class="p">,</span> <span class="n">tx</span><span class="o">=</span><span class="mi">33</span><span class="p">,</span> <span class="n">rx</span><span class="o">=</span><span class="mi">32</span><span class="p">)</span>
<span class="n">uart1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>  <span class="c1"># write 5 bytes</span>
<span class="n">uart1</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>         <span class="c1"># read up to 5 bytes</span>
</pre></div>
</div>
<p>The ESP32 has three hardware UARTs: UART0, UART1 and UART2.
They each have default GPIO assigned to them, however depending on your
ESP32 variant and board, these pins may conflict with embedded flash,
onboard PSRAM or peripherals.</p>
<p>Any GPIO can be used for hardware UARTs using the GPIO matrix, so to avoid
conflicts simply provide <code class="docutils literal notranslate"><span class="pre">tx</span></code> and <code class="docutils literal notranslate"><span class="pre">rx</span></code> pins when constructing. The default
pins listed below.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p></p></th>
<th class="head"><p>UART0</p></th>
<th class="head"><p>UART1</p></th>
<th class="head"><p>UART2</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>tx</p></td>
<td><p>1</p></td>
<td><p>10</p></td>
<td><p>17</p></td>
</tr>
<tr class="row-odd"><td><p>rx</p></td>
<td><p>3</p></td>
<td><p>9</p></td>
<td><p>16</p></td>
</tr>
</tbody>
</table>
</section>
<section id="pwm-pulse-width-modulation">
<h2>PWM (pulse width modulation)<a class="headerlink" href="#pwm-pulse-width-modulation" title="Permalink to this headline">¶</a></h2>
<p>PWM can be enabled on all output-enabled pins. The base frequency can
range from 1Hz to 40MHz but there is a tradeoff; as the base frequency
<em>increases</em> the duty resolution <em>decreases</em>. See
<a class="reference external" href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/peripherals/ledc.html">LED Control</a>
for more details.
Currently the duty cycle has to be in the range of 0-1023.</p>
<p>Use the <code class="docutils literal notranslate"><span class="pre">machine.PWM</span></code> class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">Pin</span><span class="p">,</span> <span class="n">PWM</span>

<span class="n">pwm0</span> <span class="o">=</span> <span class="n">PWM</span><span class="p">(</span><span class="n">Pin</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>      <span class="c1"># create PWM object from a pin</span>
<span class="n">pwm0</span><span class="o">.</span><span class="n">freq</span><span class="p">()</span>             <span class="c1"># get current frequency</span>
<span class="n">pwm0</span><span class="o">.</span><span class="n">freq</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>         <span class="c1"># set frequency</span>
<span class="n">pwm0</span><span class="o">.</span><span class="n">duty</span><span class="p">()</span>             <span class="c1"># get current duty cycle</span>
<span class="n">pwm0</span><span class="o">.</span><span class="n">duty</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span>          <span class="c1"># set duty cycle</span>
<span class="n">pwm0</span><span class="o">.</span><span class="n">deinit</span><span class="p">()</span>           <span class="c1"># turn off PWM on the pin</span>

<span class="n">pwm2</span> <span class="o">=</span> <span class="n">PWM</span><span class="p">(</span><span class="n">Pin</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">freq</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span> <span class="n">duty</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span> <span class="c1"># create and configure in one go</span>
</pre></div>
</div>
</section>
<section id="adc-analog-to-digital-conversion">
<h2>ADC (analog to digital conversion)<a class="headerlink" href="#adc-analog-to-digital-conversion" title="Permalink to this headline">¶</a></h2>
<p>On the ESP32 ADC functionality is available on Pins 32-39. Note that, when
using the default configuration, input voltages on the ADC pin must be between
0.0v and 1.0v (anything above 1.0v will just read as 4095).  Attenuation must
be applied in order to increase this usable voltage range.</p>
<p>Use the <a class="reference internal" href="../library/machine.ADC.html#machine-adc"><span class="std std-ref">machine.ADC</span></a> class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">ADC</span>

<span class="n">adc</span> <span class="o">=</span> <span class="n">ADC</span><span class="p">(</span><span class="n">Pin</span><span class="p">(</span><span class="mi">32</span><span class="p">))</span>          <span class="c1"># create ADC object on ADC pin</span>
<span class="n">adc</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>                  <span class="c1"># read value, 0-4095 across voltage range 0.0v - 1.0v</span>

<span class="n">adc</span><span class="o">.</span><span class="n">atten</span><span class="p">(</span><span class="n">ADC</span><span class="o">.</span><span class="n">ATTN_11DB</span><span class="p">)</span>    <span class="c1"># set 11dB input attenuation (voltage range roughly 0.0v - 3.6v)</span>
<span class="n">adc</span><span class="o">.</span><span class="n">width</span><span class="p">(</span><span class="n">ADC</span><span class="o">.</span><span class="n">WIDTH_9BIT</span><span class="p">)</span>   <span class="c1"># set 9 bit return values (returned range 0-511)</span>
<span class="n">adc</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>                  <span class="c1"># read value using the newly configured attenuation and width</span>
</pre></div>
</div>
<p>ESP32 specific ADC class method reference:</p>
<dl class="py method">
<dt class="sig sig-object py" id="ADC.atten">
<span class="sig-prename descclassname"><span class="pre">ADC.</span></span><span class="sig-name descname"><span class="pre">atten</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">attenuation</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ADC.atten" title="Permalink to this definition">¶</a></dt>
<dd><p>This method allows for the setting of the amount of attenuation on the
input of the ADC. This allows for a wider possible input voltage range,
at the cost of accuracy (the same number of bits now represents a wider
range). The possible attenuation options are:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ADC.ATTN_0DB</span></code>: 0dB attenuation, gives a maximum input voltage
of 1.00v - this is the default configuration</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ADC.ATTN_2_5DB</span></code>: 2.5dB attenuation, gives a maximum input voltage
of approximately 1.34v</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ADC.ATTN_6DB</span></code>: 6dB attenuation, gives a maximum input voltage
of approximately 2.00v</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ADC.ATTN_11DB</span></code>: 11dB attenuation, gives a maximum input voltage
of approximately 3.6v</p></li>
</ul>
</div></blockquote>
</dd></dl>

<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Despite 11dB attenuation allowing for up to a 3.6v range, note that the
absolute maximum voltage rating for the input pins is 3.6v, and so going
near this boundary may be damaging to the IC!</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="ADC.width">
<span class="sig-prename descclassname"><span class="pre">ADC.</span></span><span class="sig-name descname"><span class="pre">width</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">width</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#ADC.width" title="Permalink to this definition">¶</a></dt>
<dd><p>This method allows for the setting of the number of bits to be utilised
and returned during ADC reads. Possible width options are:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ADC.WIDTH_9BIT</span></code>: 9 bit data</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ADC.WIDTH_10BIT</span></code>: 10 bit data</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ADC.WIDTH_11BIT</span></code>: 11 bit data</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ADC.WIDTH_12BIT</span></code>: 12 bit data - this is the default configuration</p></li>
</ul>
</div></blockquote>
</dd></dl>

</section>
<section id="software-spi-bus">
<h2>Software SPI bus<a class="headerlink" href="#software-spi-bus" title="Permalink to this headline">¶</a></h2>
<p>Software SPI (using bit-banging) works on all pins, and is accessed via the
<a class="reference internal" href="../library/machine.SPI.html#machine-softspi"><span class="std std-ref">machine.SoftSPI</span></a> class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">Pin</span><span class="p">,</span> <span class="n">SoftSPI</span>

<span class="c1"># construct a SoftSPI bus on the given pins</span>
<span class="c1"># polarity is the idle state of SCK</span>
<span class="c1"># phase=0 means sample on the first edge of SCK, phase=1 means the second</span>
<span class="n">spi</span> <span class="o">=</span> <span class="n">SoftSPI</span><span class="p">(</span><span class="n">baudrate</span><span class="o">=</span><span class="mi">100000</span><span class="p">,</span> <span class="n">polarity</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sck</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">mosi</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">miso</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>

<span class="n">spi</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">baudrate</span><span class="o">=</span><span class="mi">200000</span><span class="p">)</span> <span class="c1"># set the baudrate</span>

<span class="n">spi</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>            <span class="c1"># read 10 bytes on MISO</span>
<span class="n">spi</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">)</span>      <span class="c1"># read 10 bytes while outputting 0xff on MOSI</span>

<span class="n">buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>     <span class="c1"># create a buffer</span>
<span class="n">spi</span><span class="o">.</span><span class="n">readinto</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>       <span class="c1"># read into the given buffer (reads 50 bytes in this case)</span>
<span class="n">spi</span><span class="o">.</span><span class="n">readinto</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">)</span> <span class="c1"># read into the given buffer and output 0xff on MOSI</span>

<span class="n">spi</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;12345&#39;</span><span class="p">)</span>     <span class="c1"># write 5 bytes on MOSI</span>

<span class="n">buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>      <span class="c1"># create a buffer</span>
<span class="n">spi</span><span class="o">.</span><span class="n">write_readinto</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;1234&#39;</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span> <span class="c1"># write to MOSI and read from MISO into the buffer</span>
<span class="n">spi</span><span class="o">.</span><span class="n">write_readinto</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span> <span class="c1"># write buf to MOSI and read MISO back into buf</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Currently <em>all</em> of <code class="docutils literal notranslate"><span class="pre">sck</span></code>, <code class="docutils literal notranslate"><span class="pre">mosi</span></code> and <code class="docutils literal notranslate"><span class="pre">miso</span></code> <em>must</em> be specified when
initialising Software SPI.</p>
</div>
</section>
<section id="hardware-spi-bus">
<h2>Hardware SPI bus<a class="headerlink" href="#hardware-spi-bus" title="Permalink to this headline">¶</a></h2>
<p>There are two hardware SPI channels that allow faster transmission
rates (up to 80Mhz). These may be used on any IO pins that support the
required direction and are otherwise unused (see <a class="reference internal" href="#pins-and-gpio"><span class="std std-ref">Pins and GPIO</span></a>)
but if they are not configured to their default pins then they need to
pass through an extra layer of GPIO multiplexing, which can impact
their reliability at high speeds. Hardware SPI channels are limited
to 40MHz when used on pins other than the default ones listed below.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 39%" />
<col style="width: 43%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p></p></th>
<th class="head"><p>HSPI (id=1)</p></th>
<th class="head"><p>VSPI (id=2)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>sck</p></td>
<td><p>14</p></td>
<td><p>18</p></td>
</tr>
<tr class="row-odd"><td><p>mosi</p></td>
<td><p>13</p></td>
<td><p>23</p></td>
</tr>
<tr class="row-even"><td><p>miso</p></td>
<td><p>12</p></td>
<td><p>19</p></td>
</tr>
</tbody>
</table>
<p>Hardware SPI is accessed via the <a class="reference internal" href="../library/machine.SPI.html#machine-spi"><span class="std std-ref">machine.SPI</span></a> class and
has the same methods as software SPI above:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">Pin</span><span class="p">,</span> <span class="n">SPI</span>

<span class="n">hspi</span> <span class="o">=</span> <span class="n">SPI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10000000</span><span class="p">)</span>
<span class="n">hspi</span> <span class="o">=</span> <span class="n">SPI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10000000</span><span class="p">,</span> <span class="n">sck</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">14</span><span class="p">),</span> <span class="n">mosi</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">13</span><span class="p">),</span> <span class="n">miso</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">12</span><span class="p">))</span>
<span class="n">vspi</span> <span class="o">=</span> <span class="n">SPI</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">baudrate</span><span class="o">=</span><span class="mi">80000000</span><span class="p">,</span> <span class="n">polarity</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">bits</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">firstbit</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sck</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">18</span><span class="p">),</span> <span class="n">mosi</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">23</span><span class="p">),</span> <span class="n">miso</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="software-i2c-bus">
<h2>Software I2C bus<a class="headerlink" href="#software-i2c-bus" title="Permalink to this headline">¶</a></h2>
<p>Software I2C (using bit-banging) works on all output-capable pins, and is
accessed via the <a class="reference internal" href="../library/machine.I2C.html#machine-softi2c"><span class="std std-ref">machine.SoftI2C</span></a> class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">Pin</span><span class="p">,</span> <span class="n">SoftI2C</span>

<span class="n">i2c</span> <span class="o">=</span> <span class="n">SoftI2C</span><span class="p">(</span><span class="n">scl</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">sda</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">freq</span><span class="o">=</span><span class="mi">100000</span><span class="p">)</span>

<span class="n">i2c</span><span class="o">.</span><span class="n">scan</span><span class="p">()</span>              <span class="c1"># scan for devices</span>

<span class="n">i2c</span><span class="o">.</span><span class="n">readfrom</span><span class="p">(</span><span class="mh">0x3a</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>   <span class="c1"># read 4 bytes from device with address 0x3a</span>
<span class="n">i2c</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="mh">0x3a</span><span class="p">,</span> <span class="s1">&#39;12&#39;</span><span class="p">)</span> <span class="c1"># write &#39;12&#39; to device with address 0x3a</span>

<span class="n">buf</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>     <span class="c1"># create a buffer with 10 bytes</span>
<span class="n">i2c</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="mh">0x3a</span><span class="p">,</span> <span class="n">buf</span><span class="p">)</span>  <span class="c1"># write the given buffer to the peripheral</span>
</pre></div>
</div>
</section>
<section id="hardware-i2c-bus">
<h2>Hardware I2C bus<a class="headerlink" href="#hardware-i2c-bus" title="Permalink to this headline">¶</a></h2>
<p>There are two hardware I2C peripherals with identifiers 0 and 1.  Any available
output-capable pins can be used for SCL and SDA but the defaults are given
below.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 39%" />
<col style="width: 43%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p></p></th>
<th class="head"><p>I2C(0)</p></th>
<th class="head"><p>I2C(1)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>scl</p></td>
<td><p>18</p></td>
<td><p>25</p></td>
</tr>
<tr class="row-odd"><td><p>sda</p></td>
<td><p>19</p></td>
<td><p>26</p></td>
</tr>
</tbody>
</table>
<p>The driver is accessed via the <a class="reference internal" href="../library/machine.I2C.html#machine-i2c"><span class="std std-ref">machine.I2C</span></a> class and
has the same methods as software I2C above:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">Pin</span><span class="p">,</span> <span class="n">I2C</span>

<span class="n">i2c</span> <span class="o">=</span> <span class="n">I2C</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">i2c</span> <span class="o">=</span> <span class="n">I2C</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">scl</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="n">sda</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">freq</span><span class="o">=</span><span class="mi">400000</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="i2s-bus">
<h2>I2S bus<a class="headerlink" href="#i2s-bus" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="../library/machine.I2S.html#machine-i2s"><span class="std std-ref">machine.I2S</span></a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">I2S</span><span class="p">,</span> <span class="n">Pin</span>

<span class="n">i2s</span> <span class="o">=</span> <span class="n">I2S</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sck</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">13</span><span class="p">),</span> <span class="n">ws</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">14</span><span class="p">),</span> <span class="n">sd</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">34</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="n">I2S</span><span class="o">.</span><span class="n">TX</span><span class="p">,</span> <span class="n">bits</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">I2S</span><span class="o">.</span><span class="n">STEREO</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="mi">44100</span><span class="p">,</span> <span class="n">ibuf</span><span class="o">=</span><span class="mi">40000</span><span class="p">)</span> <span class="c1"># create I2S object</span>
<span class="n">i2s</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>             <span class="c1"># write buffer of audio samples to I2S device</span>

<span class="n">i2s</span> <span class="o">=</span> <span class="n">I2S</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">sck</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">33</span><span class="p">),</span> <span class="n">ws</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">25</span><span class="p">),</span> <span class="n">sd</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">32</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="n">I2S</span><span class="o">.</span><span class="n">RX</span><span class="p">,</span> <span class="n">bits</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">I2S</span><span class="o">.</span><span class="n">MONO</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="mi">22050</span><span class="p">,</span> <span class="n">ibuf</span><span class="o">=</span><span class="mi">40000</span><span class="p">)</span> <span class="c1"># create I2S object</span>
<span class="n">i2s</span><span class="o">.</span><span class="n">readinto</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>          <span class="c1"># fill buffer with audio samples from I2S device</span>
</pre></div>
</div>
<p>The I2S class is currently available as a Technical Preview.  During the preview period, feedback from
users is encouraged.  Based on this feedback, the I2S class API and implementation may be changed.</p>
<p>ESP32 has two I2S buses with id=0 and id=1</p>
</section>
<section id="real-time-clock-rtc">
<h2>Real time clock (RTC)<a class="headerlink" href="#real-time-clock-rtc" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="../library/machine.RTC.html#machine-rtc"><span class="std std-ref">machine.RTC</span></a></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">RTC</span>

<span class="n">rtc</span> <span class="o">=</span> <span class="n">RTC</span><span class="p">()</span>
<span class="n">rtc</span><span class="o">.</span><span class="n">datetime</span><span class="p">((</span><span class="mi">2017</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">48</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="c1"># set a specific date and time</span>
<span class="n">rtc</span><span class="o">.</span><span class="n">datetime</span><span class="p">()</span> <span class="c1"># get date and time</span>
</pre></div>
</div>
</section>
<section id="wdt-watchdog-timer">
<h2>WDT (Watchdog timer)<a class="headerlink" href="#wdt-watchdog-timer" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="../library/machine.WDT.html#machine-wdt"><span class="std std-ref">machine.WDT</span></a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">WDT</span>

<span class="c1"># enable the WDT with a timeout of 5s (1s is the minimum)</span>
<span class="n">wdt</span> <span class="o">=</span> <span class="n">WDT</span><span class="p">(</span><span class="n">timeout</span><span class="o">=</span><span class="mi">5000</span><span class="p">)</span>
<span class="n">wdt</span><span class="o">.</span><span class="n">feed</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="deep-sleep-mode">
<h2>Deep-sleep mode<a class="headerlink" href="#deep-sleep-mode" title="Permalink to this headline">¶</a></h2>
<p>The following code can be used to sleep, wake and check the reset cause:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">machine</span>

<span class="c1"># check if the device woke from a deep sleep</span>
<span class="k">if</span> <span class="n">machine</span><span class="o">.</span><span class="n">reset_cause</span><span class="p">()</span> <span class="o">==</span> <span class="n">machine</span><span class="o">.</span><span class="n">DEEPSLEEP_RESET</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;woke from a deep sleep&#39;</span><span class="p">)</span>

<span class="c1"># put the device to sleep for 10 seconds</span>
<span class="n">machine</span><span class="o">.</span><span class="n">deepsleep</span><span class="p">(</span><span class="mi">10000</span><span class="p">)</span>
</pre></div>
</div>
<p>Notes:</p>
<ul>
<li><p>Calling <code class="docutils literal notranslate"><span class="pre">deepsleep()</span></code> without an argument will put the device to sleep
indefinitely</p></li>
<li><p>A software reset does not change the reset cause</p></li>
<li><p>There may be some leakage current flowing through enabled internal pullups.
To further reduce power consumption it is possible to disable the internal pullups:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p1</span> <span class="o">=</span> <span class="n">Pin</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">Pin</span><span class="o">.</span><span class="n">IN</span><span class="p">,</span> <span class="n">Pin</span><span class="o">.</span><span class="n">PULL_HOLD</span><span class="p">)</span>
</pre></div>
</div>
<p>After leaving deepsleep it may be necessary to un-hold the pin explicitly (e.g. if
it is an output pin) via:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p1</span> <span class="o">=</span> <span class="n">Pin</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">Pin</span><span class="o">.</span><span class="n">OUT</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
</section>
<section id="sd-card">
<h2>SD card<a class="headerlink" href="#sd-card" title="Permalink to this headline">¶</a></h2>
<p>See <a class="reference internal" href="../library/machine.SDCard.html#machine-sdcard"><span class="std std-ref">machine.SDCard</span></a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">machine</span><span class="o">,</span> <span class="nn">os</span>

<span class="c1"># Slot 2 uses pins sck=18, cs=5, miso=19, mosi=23</span>
<span class="n">sd</span> <span class="o">=</span> <span class="n">machine</span><span class="o">.</span><span class="n">SDCard</span><span class="p">(</span><span class="n">slot</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">os</span><span class="o">.</span><span class="n">mount</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span> <span class="s2">&quot;/sd&quot;</span><span class="p">)</span>  <span class="c1"># mount</span>

<span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s1">&#39;/sd&#39;</span><span class="p">)</span>    <span class="c1"># list directory contents</span>

<span class="n">os</span><span class="o">.</span><span class="n">umount</span><span class="p">(</span><span class="s1">&#39;/sd&#39;</span><span class="p">)</span>     <span class="c1"># eject</span>
</pre></div>
</div>
</section>
<section id="rmt">
<h2>RMT<a class="headerlink" href="#rmt" title="Permalink to this headline">¶</a></h2>
<p>The RMT is ESP32-specific and allows generation of accurate digital pulses with
12.5ns resolution.  See <a class="reference internal" href="../library/esp32.html#esp32-rmt"><span class="std std-ref">esp32.RMT</span></a> for details.  Usage is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">esp32</span>
<span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">Pin</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">esp32</span><span class="o">.</span><span class="n">RMT</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pin</span><span class="o">=</span><span class="n">Pin</span><span class="p">(</span><span class="mi">18</span><span class="p">),</span> <span class="n">clock_div</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
<span class="n">r</span>   <span class="c1"># RMT(channel=0, pin=18, source_freq=80000000, clock_div=8)</span>
<span class="c1"># The channel resolution is 100ns (1/(source_freq/clock_div)).</span>
<span class="n">r</span><span class="o">.</span><span class="n">write_pulses</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">40</span><span class="p">),</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># Send 0 for 100ns, 1 for 2000ns, 0 for 200ns, 1 for 4000ns</span>
</pre></div>
</div>
</section>
<section id="onewire-driver">
<h2>OneWire driver<a class="headerlink" href="#onewire-driver" title="Permalink to this headline">¶</a></h2>
<p>The OneWire driver is implemented in software and works on all pins:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">Pin</span>
<span class="kn">import</span> <span class="nn">onewire</span>

<span class="n">ow</span> <span class="o">=</span> <span class="n">onewire</span><span class="o">.</span><span class="n">OneWire</span><span class="p">(</span><span class="n">Pin</span><span class="p">(</span><span class="mi">12</span><span class="p">))</span> <span class="c1"># create a OneWire bus on GPIO12</span>
<span class="n">ow</span><span class="o">.</span><span class="n">scan</span><span class="p">()</span>               <span class="c1"># return a list of devices on the bus</span>
<span class="n">ow</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>              <span class="c1"># reset the bus</span>
<span class="n">ow</span><span class="o">.</span><span class="n">readbyte</span><span class="p">()</span>           <span class="c1"># read a byte</span>
<span class="n">ow</span><span class="o">.</span><span class="n">writebyte</span><span class="p">(</span><span class="mh">0x12</span><span class="p">)</span>      <span class="c1"># write a byte on the bus</span>
<span class="n">ow</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;123&#39;</span><span class="p">)</span>         <span class="c1"># write bytes on the bus</span>
<span class="n">ow</span><span class="o">.</span><span class="n">select_rom</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;12345678&#39;</span><span class="p">)</span> <span class="c1"># select a specific device by its ROM code</span>
</pre></div>
</div>
<p>There is a specific driver for DS18S20 and DS18B20 devices:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">ds18x20</span>
<span class="n">ds</span> <span class="o">=</span> <span class="n">ds18x20</span><span class="o">.</span><span class="n">DS18X20</span><span class="p">(</span><span class="n">ow</span><span class="p">)</span>
<span class="n">roms</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">scan</span><span class="p">()</span>
<span class="n">ds</span><span class="o">.</span><span class="n">convert_temp</span><span class="p">()</span>
<span class="n">time</span><span class="o">.</span><span class="n">sleep_ms</span><span class="p">(</span><span class="mi">750</span><span class="p">)</span>
<span class="k">for</span> <span class="n">rom</span> <span class="ow">in</span> <span class="n">roms</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">read_temp</span><span class="p">(</span><span class="n">rom</span><span class="p">))</span>
</pre></div>
</div>
<p>Be sure to put a 4.7k pull-up resistor on the data line.  Note that
the <code class="docutils literal notranslate"><span class="pre">convert_temp()</span></code> method must be called each time you want to
sample the temperature.</p>
</section>
<section id="neopixel-and-apa106-driver">
<h2>NeoPixel and APA106 driver<a class="headerlink" href="#neopixel-and-apa106-driver" title="Permalink to this headline">¶</a></h2>
<p>Use the <code class="docutils literal notranslate"><span class="pre">neopixel</span></code> and <code class="docutils literal notranslate"><span class="pre">apa106</span></code> modules:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">Pin</span>
<span class="kn">from</span> <span class="nn">neopixel</span> <span class="kn">import</span> <span class="n">NeoPixel</span>

<span class="n">pin</span> <span class="o">=</span> <span class="n">Pin</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Pin</span><span class="o">.</span><span class="n">OUT</span><span class="p">)</span>   <span class="c1"># set GPIO0 to output to drive NeoPixels</span>
<span class="n">np</span> <span class="o">=</span> <span class="n">NeoPixel</span><span class="p">(</span><span class="n">pin</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>   <span class="c1"># create NeoPixel driver on GPIO0 for 8 pixels</span>
<span class="n">np</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span> <span class="c1"># set the first pixel to white</span>
<span class="n">np</span><span class="o">.</span><span class="n">write</span><span class="p">()</span>              <span class="c1"># write data to all pixels</span>
<span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>         <span class="c1"># get first pixel colour</span>
</pre></div>
</div>
<p>The APA106 driver extends NeoPixel, but internally uses a different colour order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">apa106</span> <span class="kn">import</span> <span class="n">APA106</span>
<span class="n">ap</span> <span class="o">=</span> <span class="n">APA106</span><span class="p">(</span><span class="n">pin</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>For low-level driving of a NeoPixel:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">esp</span>
<span class="n">esp</span><span class="o">.</span><span class="n">neopixel_write</span><span class="p">(</span><span class="n">pin</span><span class="p">,</span> <span class="n">grb_buf</span><span class="p">,</span> <span class="n">is800khz</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>By default <code class="docutils literal notranslate"><span class="pre">NeoPixel</span></code> is configured to control the more popular <em>800kHz</em>
units. It is possible to use alternative timing to control other (typically
400kHz) devices by passing <code class="docutils literal notranslate"><span class="pre">timing=0</span></code> when constructing the
<code class="docutils literal notranslate"><span class="pre">NeoPixel</span></code> object.</p>
</div>
<p>APA102 (DotStar) uses a different driver as it has an additional clock pin.</p>
</section>
<section id="capacitive-touch">
<h2>Capacitive touch<a class="headerlink" href="#capacitive-touch" title="Permalink to this headline">¶</a></h2>
<p>Use the <code class="docutils literal notranslate"><span class="pre">TouchPad</span></code> class in the <code class="docutils literal notranslate"><span class="pre">machine</span></code> module:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">TouchPad</span><span class="p">,</span> <span class="n">Pin</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">TouchPad</span><span class="p">(</span><span class="n">Pin</span><span class="p">(</span><span class="mi">14</span><span class="p">))</span>
<span class="n">t</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>              <span class="c1"># Returns a smaller number when touched</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">TouchPad.read</span></code> returns a value relative to the capacitive variation. Small numbers (typically in
the <em>tens</em>) are common when a pin is touched, larger numbers (above <em>one thousand</em>) when
no touch is present. However the values are <em>relative</em> and can vary depending on the board
and surrounding composition so some calibration may be required.</p>
<p>There are ten capacitive touch-enabled pins that can be used on the ESP32: 0, 2, 4, 12, 13
14, 15, 27, 32, 33. Trying to assign to any other pins will result in a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>.</p>
<p>Note that TouchPads can be used to wake an ESP32 from sleep:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">machine</span>
<span class="kn">from</span> <span class="nn">machine</span> <span class="kn">import</span> <span class="n">TouchPad</span><span class="p">,</span> <span class="n">Pin</span>
<span class="kn">import</span> <span class="nn">esp32</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">TouchPad</span><span class="p">(</span><span class="n">Pin</span><span class="p">(</span><span class="mi">14</span><span class="p">))</span>
<span class="n">t</span><span class="o">.</span><span class="n">config</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>               <span class="c1"># configure the threshold at which the pin is considered touched</span>
<span class="n">esp32</span><span class="o">.</span><span class="n">wake_on_touch</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">machine</span><span class="o">.</span><span class="n">lightsleep</span><span class="p">()</span>        <span class="c1"># put the MCU to sleep until a touchpad is touched</span>
</pre></div>
</div>
<p>For more details on touchpads refer to <a class="reference external" href="https://docs.espressif.com/projects/esp-idf/en/latest/api-reference/peripherals/touch_pad.html">Espressif Touch Sensor</a>.</p>
</section>
<section id="dht-driver">
<h2>DHT driver<a class="headerlink" href="#dht-driver" title="Permalink to this headline">¶</a></h2>
<p>The DHT driver is implemented in software and works on all pins:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">dht</span>
<span class="kn">import</span> <span class="nn">machine</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">dht</span><span class="o">.</span><span class="n">DHT11</span><span class="p">(</span><span class="n">machine</span><span class="o">.</span><span class="n">Pin</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="n">d</span><span class="o">.</span><span class="n">measure</span><span class="p">()</span>
<span class="n">d</span><span class="o">.</span><span class="n">temperature</span><span class="p">()</span> <span class="c1"># eg. 23 (°C)</span>
<span class="n">d</span><span class="o">.</span><span class="n">humidity</span><span class="p">()</span>    <span class="c1"># eg. 41 (% RH)</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">dht</span><span class="o">.</span><span class="n">DHT22</span><span class="p">(</span><span class="n">machine</span><span class="o">.</span><span class="n">Pin</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="n">d</span><span class="o">.</span><span class="n">measure</span><span class="p">()</span>
<span class="n">d</span><span class="o">.</span><span class="n">temperature</span><span class="p">()</span> <span class="c1"># eg. 23.6 (°C)</span>
<span class="n">d</span><span class="o">.</span><span class="n">humidity</span><span class="p">()</span>    <span class="c1"># eg. 41.3 (% RH)</span>
</pre></div>
</div>
</section>
<section id="webrepl-web-browser-interactive-prompt">
<h2>WebREPL (web browser interactive prompt)<a class="headerlink" href="#webrepl-web-browser-interactive-prompt" title="Permalink to this headline">¶</a></h2>
<p>WebREPL (REPL over WebSockets, accessible via a web browser) is an
experimental feature available in ESP32 port. Download web client
from <a class="reference external" href="https://github.com/micropython/webrepl">https://github.com/micropython/webrepl</a> (hosted version available
at <a class="reference external" href="http://micropython.org/webrepl">http://micropython.org/webrepl</a>), and configure it by executing:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">webrepl_setup</span>
</pre></div>
</div>
<p>and following on-screen instructions. After reboot, it will be available
for connection. If you disabled automatic start-up on boot, you may
run configured daemon on demand using:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">webrepl</span>
<span class="n">webrepl</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="c1"># or, start with a specific password</span>
<span class="n">webrepl</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">password</span><span class="o">=</span><span class="s1">&#39;mypass&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The WebREPL daemon listens on all active interfaces, which can be STA or
AP.  This allows you to connect to the ESP32 via a router (the STA
interface) or directly when connected to its access point.</p>
<p>In addition to terminal/command prompt access, WebREPL also has provision
for file transfer (both upload and download).  The web client has buttons for
the corresponding functions, or you can use the command-line client
<code class="docutils literal notranslate"><span class="pre">webrepl_cli.py</span></code> from the repository above.</p>
<p>See the MicroPython forum for other community-supported alternatives
to transfer files to an ESP32 board.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../esp8266/tutorial/nextsteps.html" class="btn btn-neutral float-left" title="15. Next steps" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="general.html" class="btn btn-neutral float-right" title="General information about the ESP32 port" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright - The MicroPython Documentation is Copyright © 2014-2021, Damien P. George, Paul Sokolovsky, and contributors.
      <span class="lastupdated">Last updated on 08 Nov 2021.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Versions and Downloads</span>
    latest
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Versions</dt>
      
        <dd><a href="//en/latest">latest</a></dd>
      
    </dl>
    <dl>
      <dt>Downloads</dt>
      
        <dd><a href="//en/latest/micropython-docs.pdf">PDF</a></dd>
      
    </dl>
    <hr/>
    <dl>
      <dt>External links</dt>
        <dd>
          <a href="https://www.micropython.org">micropython.org</a>
        </dd>
        <dd>
          <a href="https://github.com/micropython/micropython">GitHub</a>
        </dd>
    </dl>
  </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>